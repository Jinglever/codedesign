### 清单
|模式|概要|什么时候选用|注意|实操|
|:--|:--|:--|:--|:--|
|观察者|在对象之间定义一个一对多的依赖关系，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知|<li>观察者变动较频繁</li><li>希望借助异步来提高吞吐量</li>|<li>同步阻塞</li><li>异步非阻塞</li><li>进程内</li><li>进程间</li>|<li>线程池</li><li>消息队列</li>|
|模板|在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现，这里的“算法”可以理解为广义上的“业务逻辑”|<li>复用</li><li>扩展</li>|-|<li>继承</li><li>抽象</li>|
|策略|定义一簇算法类，将每个算法分别封装起来，让它们可以互相替换|<li>概念上属于同类的不同对象，可对外暴露同样的接口，而各自有不同的实现</li><li>添加新“策略”时可以最小化、集中化代码改动</li>|-|<li>不同策略实现相同的接口或继承相同的父类</li><li>工厂类运行时确定选用的“策略”</li><li>查表法或if-else分支判断</li>|
|职责链|将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够过处理它为止|<li>过滤器</li><li>拦截器</li>|-|<li>处理器Filter</li><li>处理器链FilterChain</li>|
|状态|状态机的一种实现方式|状态种类不太多，而事件触发的动作比较复杂|-|<li>每种状态封装成一个类，将事件和动作包在其中</li>|
|迭代器|用来遍历集合对象|-|遍历的同时增删集合元素，会发生未决行为|<li>容器，定义iterator()方法</li><li>迭代器，定义三个方法：hasNext(), currentItem(), next()</li>|
|访问者|允许一个或者多个操作应用到一组对象上，解耦操作和对象本身|很少用，不好理解|-|将操作独立出来一个类，对一组不同的对象进行操作|
|备忘者|-|-|-|-|
|-|-|-|-|-|


<br>
<br>

### 设计模式要干的事情就是解耦
- 创建型模式是将创建和使用代码解耦
- 结构型模式是将不同的功能代码解耦
- 行为型模式是将不同的行为代码解耦
    - 观察者模型，是将观察者和被观察者代码解耦

<br>

### 模板模式
- 复用
    - 所有子类可以复用父类中提供的模板方法的代码
- 扩展
    - 框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能

<br>

### 回调
    - 简介
        - 回调是一种双向调用关系。A类事先注册某个函数F到B类，A类在调用B类中的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫做“回调”。
    - 同步回调
        - 函数返回之前执行回调函数
        - 像模板模式
            - 从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。
    - 异步回调
        - 函数返回之后执行回调函数
        - 像观察者模式

<br>

### 策略模式
- 解耦的是策略的定义、创建、使用三个部分

<br>

### 状态机
- 三种实现方式
    - 分支逻辑法
        - 利用if-else或者switch-case；对简单状态机来说，这个方式最简单直接。
    - 查表法
        - 对于状态非常多，状态转移比较复杂的状态机，这个方式比较合适；通过二维数组来表示状态转移图，能极大提高代码的可读性和可维护性。
    - 状态模式
        - 对于状态不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机来说，这个方式是首选。

<br>

### 迭代器模式
- 遍历集合一般有三种方式：for循环、foreach循环、迭代器遍历；后两种都可以看做迭代器遍历；
- 迭代器相对for循环的三个优势
    - 迭代器模式封装集合内部的复杂数据结构，开发者不用了解如何遍历，直接使用容器提供的迭代器即可
    - 迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一
    - 迭代器模式让添加新的遍历算法更加容易，更符合开闭原则；另外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也更加容易
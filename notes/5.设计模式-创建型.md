### 清单
|模式|概要|什么时候选用|注意|实操|
|:--|:--|:--|:--|:--|
|单例|一个类只允许创建一个对象/实例|<li>处理资源访问冲突</li><li>表示全局唯一类</li> |<li>线程安全问题</li>|<li>饿汉式</li><li>懒汉式</li><li>...</li>|
|工厂|将对象的创建和使用相分离|<li>封装变化</li><li>代码复用</li><li>隔离复杂性</li><li>控制复杂度</li>|<li>别滥用</li>|creatXX() 或者 getInstance()|
|建造者|在设置完属性后才真正创建对象/实例|<li>构造参数列表过长，且类属性之间有一定的依赖/约束关系</li>|- |setXX().. -> build()|
|原型|利用对已有对象（原型）进行拷贝的方式来创建新对象|<li>对象的创建成本比较大，且同一个类的不同对象之间差别不大</li>|<li>浅拷贝</li><li>深拷贝</li>|clone|

<br>
<br>

### 单例模式
- 实现方式
    - 饿汉式
        - 在类加载的时候，instance静态实例就已经创建并初始化好了。
    - 懒汉式
        - 延迟加载，加锁，性能差。
    - 双重检测
    - 静态内部类 - JAVA
    - 枚举
- 问题
    - 对OOP特性的支持不好
    - 单例会隐藏类之间的依赖关系
    - 单例对代码的扩展性不友好
    - 单例对代码的可测试性不友好
    - 单例不支持有参数的构造函数
- 替代方案
    - 静态方法

<br>

### 工厂模式
- 分类 （个人认为，不必纠结这个分类，根据具体的场景设计，尽量简单）
    - 简单工厂
    - 工厂方法
    - 抽象工厂
- 使用工厂模式是为了什么？
    - 封装变化
        - 创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
    - 代码复用
        - 创建代码抽离到独立的工厂类之后可以复用。
    - 隔离复杂性
        - 封装复杂的创建逻辑，调用者无需了解如何创建对象。
    - 控制复杂度
        - 将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。

<br>

### 建造者模式
- 跟工厂模式的区别
    - 工厂模式
        - 用来创建不同但类型相关的对象（继承同一个父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。
    - 建造者模式
        - 用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。
    - 比喻
        - 走进一家餐馆点餐，利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。

<br>

### 原型模式
- 对JavaScript的前端程序员来说，原型模式是一个比较常用的开发模式，因为JavaScript是一种基于原型的面向对象程序语言
- Java、C++等比较少用原型模式
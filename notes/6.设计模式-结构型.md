### 清单
|模式|概要|什么时候选用|注意|实操|
|:--|:--|:--|:--|:--|
|代理|在不改变原始类代码的情况下，通过引入代理类给原始类附加功能|<li>业务系统的非功能性需求开发</li><li>RPC</li><li>同时支持缓存和不缓存</li>|-|<li>代理类和原始类实现相同的接口，或者代理类继承原始类</li><li>将原始类的实例作为参数传入代理类，围绕此实例去附加功能</li><li>动态代理，反射</li>|
|桥接|<li>将抽象和实现解耦，让它们可以独立变化</li><li>组合优于继承</li>|<li>未来可能扩展“实现”，使用者可自由选用不同的“实现”</li><li>“抽象”和“实现”不是同一拨人维护的</li><li>此模式不常用</li>|-|“抽象”并非抽象类或接口，而是被抽象出来的一套类库，只包含骨架代码，真正的业务逻辑委派给“实现”来完成；比如 JDBC跟Driver的关系|
|装饰|通过组合来替代继承，给原始类添加增强功能|<li>可以对原始类嵌套多个装饰器</li>|-|<li>参考JAVA IO</li><li>装饰类需要跟原始类继承相同的抽象类或者接口</li><li>将原始类的实例作为参数传入装饰器，围绕此实例进行功能增强</li>|
|适配器|将不兼容的接口转换成可兼容的接口|<li>封装有缺陷的接口</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li>|-|<li>类适配器使用继承关系来实现</li><li>对象适配器使用组合关系来实现</li>|
|门面|为子系统提供一组统一的接口，定义一组高层接口让子系统更易用|<li>解决易用性问题</li><li>解决性能问题</li>|尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口|说白了就是把若干细粒度接口打包成一个较大的所谓门面接口|
|组合|将一组对象组织成树形结构，以表示一种“部分-整体”的层次结构|业务场景必须能够表示成树形结构，应用场景比较局限，所以不常用|与其说是一种设计模式，不如说是对业务场景的一种数据结构和算法的抽象|将一组对象组织成树形结构，将单个对象和组合对象都看做树中的节点，以统一处理逻辑，并且利用树形结构的特点，递归处理每个子树，从而简化代码实现|
|享元|共享的单元|当一个系统中存在大量重复对象的时候，如果这些重复对象是不可变对象，那么可以将对象设计成享元，在内存中只保留一份实例，供多处代码引用|<li>享元对象是不可变对象</li><li>对垃圾回收机制不友好，如果对象的生命周期很短，也不会被密集使用，利用享元反而可能浪费更多的内存</li>|通过工厂模式，在工厂类中，通过一个Map来缓存已经创建过的享元对象，来达到复用的目的|


<br>
<br>

### 代理模式 vs 装饰器模式
- 两者在实现上非常相像
- 区别在于应用的目的
    - 代理模式
        - 附加的是跟原始类无关的功能。
    - 装饰器模式
        - 附加的是跟原始类相关的增强功能。

<br>

### 适配器模式
- 有两种实现方式：
    - 类适配器
    - 对象适配器
- 如何选择实现方式？
    - 如果被适配类的接口不多，两种方式都行。
    - 如果被适配类接口很多，且接口定义跟适配目标类的接口定义大部分都相同，那推荐使用类适配器，因为可以少写些代码。
    - 如果被适配类接口很多，且接口定义跟适配目标类的大部分都不相同，那推荐使用对象适配器，因为组合结构相对于继承更加灵活。

<br>

### Wrapper模式
- 代理、桥接、装饰器、适配器，这4种模式的代码结构非常相似，笼统来说，可以称为Wrapper模式，也就是通过Wrapper类二次封装。
- 四者在用意上的区别
    - 代理模式
        - 主要目的是控制访问，而非加强功能，这是它跟装饰器模式的最大不同。
    - 桥接模式
        - 目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
    - 装饰器模式
        - 目的是在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
    - 适配器模式
        - 是一种事后的补偿策略，提供跟原始类不同的接口。

<br>

### 享元模式 VS 单例、缓存、对象池
- 享元模式
    - 为了实现对象复用（可同时被多处引用），节省内存
- 单例
    - 为了保证对象全局唯一（引申：多例实际上仍然是为了限制对象个数）
- 缓存
    - 为了提高提高访问效率，而非复用
- 对象池
    - 池化技术中的“复用”理解为“重复使用”（同一时间不会被多处引用，而是被一个使用者独占），主要是为了节省时间
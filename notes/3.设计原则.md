
### SOLD原则
|设计原则|缩写|解释|副作用|实操|
|:--|:--|:--|:--|:--|
|单一职责原则|SRP|一个类或者模块只负责完成一个职责（或功能）。|细粒度太细会降低代码内聚，影响代码的可维护性。|先写一个粗粒度的类满足业务需求，根据实际需要持续重构。|
|开闭原则|OCP|添加一个新功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。|支持这一原则的关键是预留扩展点，但要小心过度设计。|只要改动不破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说这是一次合格的代码改动。|
|里氏替换原则|LSP|子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。这作为一个设计原则，指导继承关系中子类该如何设计。|-|按照协议来设计，子类在设计的时候，要遵循父类的行为约定，包括函数声明实现的功能，对输入、输出、异常的约定，注释里特殊说明等，子类只能改变内部实现逻辑。|
|接口隔离原则|ISP|接口的调用者或者使用者不应该强迫依赖它不需要的接口。|||
|依赖反转原则|DIP|高层模块不要依赖底层模块，高层模块和底层模块应该通过抽象来互相依赖。||实际上平常的业务代码开发中，高层模块依赖底层模块没有任何问题。这条原则主要用来指导框架层面的设计。|

<br>

### KISS原则 - 尽量保持简单。
- 不要使用同事可能不懂的技术来实现代码。
- 不要重复造轮子，要善于使用已经有的工具类库。
- 不要过度优化。不要过度使用一些奇淫技巧（比如，位运算代替算术运算、复杂的条件语句代替if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

<br>

### YAGNI原则 - You Ain't Gonna Need it.
- 不要去设计当前用不到的功能；不要去编写当前用不到的代码。核心思想就是：不要过度设计。
- 比如，如果暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。那么在未用到ZooKeeper之前，我们没必要提前编写这部分代码。但是，这并不是说我们不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。

<br>

### DRY原则 - Don't Repeat Yourself.